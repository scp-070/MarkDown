# 会员注册

> [别人的]: https://blog.csdn.net/weixin_45260385/article/details/115830326

## **目标**

​	实现通过手机验证码来完成会员账号的注册。

## **思路**

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220609163020860.png" alt="image-20220609163020860" style="zoom:67%;" />

## **实现**

### 1、在阿里云市场购买短信验证码

控制台-云市场-已购买的服务

![image-20220608161141735](https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220608161141735.png)

这里选择的版本需要引入依赖和jar：HttpUtils，依赖看链接

（有不用加依赖直接用jdk中jar的版本）

店铺中给出的示例代码：

```java
// 短信注册
    public static void main(String[] args) {
        // 短信调用的url地址
        String host = "https://dfsns.market.alicloudapi.com";

        // 具体发送短信功能的地址
        String path = "/data/send_sms";

        // 请求方式
        String method = "POST";

        // 控制台中看购买的
        String appcode = "3e18fc018bca45b6998c23b79ac93220";

        // 封装appcode
        Map<String, String> headers = new HashMap<String, String>();
        //最后在header中的格式(中间是英文空格)为Authorization:APPCODE 83359fd73fe94948385f570e3c139105
        headers.put("Authorization", "APPCODE " + appcode);
        //根据API的要求，定义相对应的Content-Type
        headers.put("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");

       // 封装其它参数
        Map<String, String> querys = new HashMap<String, String>();
        Map<String, String> bodys = new HashMap<String, String>();
        // code为短信模板上的参数；1234为参数值，可自定义传参。当有多个参数（如TPL_0001模板），以半角逗号“，”分隔。
        bodys.put("content", "code:1234");
        bodys.put("phone_number", "19120320246");
        // 模板ID：代表整体短信文案模板
        bodys.put("template_id", "TPL_0000");


        try {
            /**
             * 重要提示如下:
             * HttpUtils请从
             * https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/src/main/java/com/aliyun/api/gateway/demo/util/HttpUtils.java
             * 下载
             *
             * 相应的依赖请参照
             * https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/pom.xml
             */
            HttpResponse response = HttpUtils.doPost(host, path, method, headers, querys, bodys);
            System.out.println(response.toString());
            //获取response的body
            //System.out.println(EntityUtils.toString(response.getEntity()));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
```

### 2、将该API在项目中使用

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220609114258025.png" alt="image-20220609114258025" style="zoom: 67%;" />



##### ==**配置视图处理器 CrowdWebMvcConfig（注解版）**==

之前的view-controller

因为这部分比较少，因此抽取出来放在一起；Spring Boot不再使用原本的Spring配置文件，而是改用配置类，而想要在MVC中设置view-controller，需要通过实现WebMvcConfigurer接口，通过其中的addViewControllers方法：

```java
@Configuration
public class CrowdWebMvcConfig implements WebMvcConfigurer {

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        // 前端请求的url地址
        String urlPath = "/auth/member/to/reg/page.html";

        // 实际后端跳转页面（会自动拼上前后缀； yml文件中）
        String viewName = "member-reg";

        // 前往用户注册页面
        registry.addViewController(urlPath).setViewName(viewName);
java
        // 前往登录页面
        registry.addViewController("/auth/member/to/login/page.html").setViewName("member-login");

        // 前往登录完成后的用户主页面
        registry.addViewController("/auth/member/to/center/page.html").setViewName("member-center");
        // 前往“我的众筹”页面
        registry.addViewController("/auth/member/to/crowd/page.html").setViewName("member-crowd");
    }
}
```

##### 修改主页中到注册页面的按钮，加入注册页面，调整 p363



> **jar包冲突，通过maven-helper插件exclude**

##### 前端点击“发送验证码”按钮：

将参数传给后端方法

```html
<!-- 给手机号的输入框加name=phoneNum -->
<div class="form-group has-success has-feedback">
    <input type="text" name="phoneNum" class="form-control" id="inputSuccess4" placeholder="请输入手机号" style="margin-top:10px;">
    <span class="glyphicon glyphicon glyphicon-earphone form-control-feedback"></span>
</div>

<!-- 按钮加上id=sendBtn -->
<button type="button" id="sendBtn" class="btn btn-lg btn-success btn-block"> 获取验证码</button>

<!-- sendBtn的单击响应函数 -->
<script type="text/javascript">
        $(function () {
            $("#sendBtn").click(function () {
                // 获取name=phoneNum的val
                var phoneNum = $.trim($("[name=phoneNum]").val());
                $.ajax({
                    url: "/auth/member/send/short/message.json",
                    type: "post",
                    data: {
                        "phoneNum":phoneNum
                    },
                    dataType: "json",
                    success: function (response) {
                        var result = response.result;
                        if (result == "SUCCESS"){
                            layer.msg("发送成功！");
                        } else {
                            layer.msg("发送失败 请重试！");
                        }
                    },
                    error: function (response) {
                        layer.msg(response.status + " " + response.statusText);
                    }
                });
            });
        });
</script>
```



##### **发送验证码的方法：**

**抽取到05-CrowdUtil.java中**

```java
/**
 * 给远程第三方短信接口发送请求返回验证码到用户的手机上
 *
 * @param host         请求的地址
 * @param path         请求的后缀
 * @param appCode      购买的api的appCode
 * @param phone_number 发送验证码的目的号码
 * @param template_id 模板id
 * @return 发送成功则返回发送的验证码，放在ResultEntity中，失败则返回失败的ResultEntity
 */
public static ResultEntity<String> sendCodeByShortMessage(
        String host,
        String path,
        String method,
        String appCode,
        String phone_number,
        String template_id
) {
    // 封装appcode
    Map<String, String> headers = new HashMap<String, String>();

    //最后在header中的格式(中间是英文空格)为Authorization:APPCODE 83359fd73fe94948385f570e3c139105
    headers.put("Authorization", "APPCODE " + appCode);
    //根据API的要求，定义相对应的Content-Type
    headers.put("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");

    // 封装其它参数
    Map<String, String> querys = new HashMap<>();
    Map<String, String> bodys = new HashMap<>();

    // 生成随机的验证码
    StringBuilder builder = new StringBuilder();
    for (int i = 0; i < 4; i++) {
        int random = (int) (Math.random() * 10);
        builder.append(random);
    }
    String code = builder.toString();
    // code为短信模板上的参数；1234为参数值，可自定义传参。当有多个参数（如TPL_0001模板），以半角逗号“，”分隔。
    // 记住"code:"不能漏
    bodys.put("content", "code:"+ code);
    bodys.put("phone_number", phone_number);
    // 模板ID：代表整体短信文案模板
    bodys.put("template_id", template_id);

    try {
        HttpResponse response = HttpUtils.doPost(host, path, method, headers, querys, bodys);
        System.out.println(response.toString());
        StatusLine statusLine = response.getStatusLine();
        int statusCode = statusLine.getStatusCode();
        String reasonPhrase = statusLine.getReasonPhrase();
        if (statusCode == 200) {
            // 成功，返回验证码
            return ResultEntity.successWithData(code);
        }
        return ResultEntity.failed(reasonPhrase);
    } catch (Exception e) {
        e.printStackTrace();
        return ResultEntity.failed(e.getMessage());
    }
}
```

##### MemberController：

通过工具方法，调用api发送验证码，并将发送成功后返回的验证码放入redis域中，方便验证时取用

```java
 // 发送验证码
    @ResponseBody
    @RequestMapping("/auth/member/send/short/message.json")
    // 从前端获取手机号
    public ResultEntity<String> sendShortMessage(@RequestParam("phoneNum") String phoneNum) {

        // 调用工具类中的发送验证码的方法，可以从配置文件中读取配置的接口信息
        ResultEntity<String> sendResultEntity = CrowdUtil.sendCodeByShortMessage(
                // 通过一个properties类+application.yml的配置，装配API需要的参数
                shortMessageProperties.getHost(),
                shortMessageProperties.getPath(),
                shortMessageProperties.getMethod(),
                shortMessageProperties.getAppCode(),phoneNum,
                shortMessageProperties.getTemplate_id());
        // 判断短信发送结果
        if (ResultEntity.SUCCESS.equals(sendResultEntity.getOperationResult())){
            // 如果成功，则将验证码存入redis
            // ①从上一步的操作结果获取随机生成的验证码
            String code = sendResultEntity.getQueryData();

            // ②拼接一个用于在redis存储数据的key
            String key = CrowdConstant.REDIS_CODE_PREFIX + phoneNum;

            // ③调用远程接口存入redis
            ResultEntity<String> saveCodeResultEntity = redisRemoteService.setRedisKeyValueWithTimeoutRemote(key, code, 15, TimeUnit.MINUTES);

            // ④判断结果
            if (ResultEntity.SUCCESS.equals(saveCodeResultEntity.getOperationResult())) {
                return ResultEntity.successWithoutData();
            } else {
                return saveCodeResultEntity;
            }
        }else {
            return sendResultEntity;
        }
    }
```

**ShortMessageProperties：**

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
@ConfigurationProperties(prefix = "short.message")
@Component
public class ShortMessageProperties {
    private String host;
    private String path;
    private String method;
    private String appCode;
    private String template_id;
}
```

**在application.yml中配置：**

```yml
spring:
  application:
    name: crowd-auth
  thymeleaf:
    prefix: classpath:/templates/
    suffix: .html
eureka:
  client:
    service-url:
      defaultZone: http://localhost:1000/eureka/
short:
  message:
    host: "https://dfsns.market.alicloudapi.com"
    path: "/data/send_sms"
    method: "POST"
    appCode: "3e18fc018bca45b6998c23b79ac93220"  # 这里就是购买得到的appCode
    template_id: "TPL_0000"
```

==**注意**==：想要使用application.yml/properties文件来配置类，需要加入依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
</dependency>
```



### **3、验证码获取完成后，进行注册操作：**

调用远程mysql接口做数据库相关操作

![image-20220609210116001](https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220609210116001.png)

##### 给t_member的login_acct增加唯一约束（索引）

![image-20220610112149420](https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220610112149420.png)

##### 在10-mysql-provider中创建远程接口

在FeignClient接口中声明新的方法（**MySQLRemoteService**）

```java
// 保存MemberPO对象到mysql中的远程调用方法
@RequestMapping("save/member/remote")
RequestEntity<String> saveMember(@RequestBody MemberPO memberPO);
```

创建controller方法

**MemberProviderController**

```java
// 保存MemberPO对象到mysql中
@RequestMapping("/save/member/remote")
ResultEntity<String> saveMember(@RequestBody MemberPO memberPO) {
    try {
        memberService.saveMember(memberPO);
        return ResultEntity.successWithoutData();
    } catch (Exception e) {
        if (e instanceof DuplicateKeyException) {
            return ResultEntity.failed(CrowdConstant.MESSAGE_SYSTEM_ERROR_ACCT_NOT_UNIQUE);
        } else {
            return ResultEntity.failed(e.getMessage());
        }
    }

}
```

**将插入方法写入service中**

 <img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220610005956597.png" alt="image-20220610005956597" style="zoom:50%;" />

**impl：**

```java
// 该类设置了@Transactional(readOnly = true)针对查询操作设置事务属性，所以这里要加注解，不然会报错
@Transactional(propagation = Propagation.REQUIRES_NEW,rollbackFor = Exception.class)
@Override
public void saveMember(MemberPO memberPO) {
    memberPOMapper.insertSelective(memberPO);
}
```

> ==saveMember是写操作，不能是只读的，要设置

==**借助postman测试post请求**==

![image-20220610112514750](https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220610112514750.png)

> ==key也得加上""==

##### ==**细节@RequestBody**==

![image-20220610113745940](https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220610113745940.png)

> controller中的方法若是不使用@RequestBody获取参数的话，也可以，但是得使用form表单提交的方式
>
> Content-Type可以不写，或者是用`application/x-www-form-urlencoded`

==但是，consumer通过远程调用接口的方式调用此方法，就必须加上@RequestBody注解==

因为不加注解，本质上还是springMVC那套，传值就是 key=value，而加上此注解接收的就是json格式的数据（"key"="value"）

![image-20220610231932168](https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220610231932168.png)





**创建MemberVO用于封装注册用户时表单的数据（v-view），修改前端注册页面，加上给对应属性“name”**

##### ==创建执行注册方法==

<font color = red>**crowdfunding12-member-authentication-consumer中的MemberController**</font>

```java
// 执行注册
@RequestMapping("/auth/member/do/register.html")
public String register(MemberVO memberVO, ModelMap modelMap) {
    // 1 从memberVO中取出验证码
    String code = memberVO.getCode();

    // 2 从redis中取出对应的验证码
    // ① 从表单中获取手机号
    String phoneNum = memberVO.getPhoneNum();
    // ② 拼接redis中存储的key
    String key = CrowdConstant.REDIS_CODE_PREFIX + phoneNum;
    // ③ 从redis缓存中取出该key对应的value
    ResultEntity<String> resultEntity = redisRemoteService.getRedisValueByKeyRemote(key);
    // ④ 取出操作结果,用来判断查询操作是否有效
    String result = resultEntity.getOperationResult();
    // ⑥ 如果查询操作失败
    if (ResultEntity.FAILED.equals(result)) {
        // 存储失败信息
        modelMap.addAttribute(CrowdConstant.ATTR_NAME_MESSAGE, resultEntity.getOperationMessage());
        // 再次跳转到注册页面
        return "member-reg";
    }
    // ⑦ 若查询结果有效,则取出redis中存储的验证码
    String redisCode = resultEntity.getQueryData();
    // ⑧ 判断是否取到queryData
    if (redisCode == null) {
        // 将错误信息存入request域中
        modelMap.addAttribute(CrowdConstant.ATTR_NAME_MESSAGE, CrowdConstant.MESSAGE_CODE_NOT_EXIST);

        // 跳转到注册页面
        return "member-reg";
    }
    // 3 成功取出验证码,比较表单中提交的验证码和redis中的验证码是否相同
    // ① 如果二者不相等
    if (!redisCode.equals(code)) {
        // 将错误信息存入request域中
        modelMap.addAttribute(CrowdConstant.ATTR_NAME_MESSAGE, CrowdConstant.MESSAGE_CODE_INVALID);
        // 返回注册页面
        return "member-reg";
    }
    // ② 如果二者相等,删除redis中保存的验证码信息,防止多次使用同一个验证码注册
    ResultEntity<String> removeRedisKeyByKeyRemote = redisRemoteService.removeRedisKeyByKeyRemote(key);
    // log.info("redis是否删除成功： " + redisValueByKeyEntity.getOperationMessage());

    // 4 注册成功,将注册信息存入mysql中
    // ① 对密码进行加密
    BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
    String oldPwd = memberVO.getUserPswd();
    String safePwd = passwordEncoder.encode(oldPwd);
    // ② 将密码更换为加密后的密码
    memberVO.setUserPswd(safePwd);
    // ③ 先将MemberVo 转换为 MemberPO
    MemberPO memberPO = new MemberPO();
    BeanUtils.copyProperties(memberVO, memberPO);
    // ④ 执行保存,将注册信息存入mysql中
    ResultEntity<String> stringResultEntity = mySQLRemoteService.saveMember(memberPO);

    // ⑤ 取出操作结果,判断是否保存成功
    String saveMemberResult = stringResultEntity.getOperationResult();

    // ⑥ 如果保存失败
    if (ResultEntity.FAILED.equals(saveMemberResult)) {

        // 将错误信息存入request域中
        modelMap.addAttribute(CrowdConstant.ATTR_NAME_MESSAGE, stringResultEntity.getOperationMessage());

        // 跳转到 注册页面
        return "member-reg";
    }
    // 5. 注册成功,跳转到登录页面
    return "member-login";

}
```

> 自己暂时没出现这个问题
>
> **注意**：由于在第一次请求中需要建立缓存、链接，操作较多，比较耗时。若按照默认的ribbon的超时时间来工作，第一次请求会超过这个时间导致超时报错。
>
> 为避免这个问题，将ribbon的超时时间延长，application.yml中配置（哪个工程需要就配哪个）

```yml
ribbon:
  ConnectTimeout: 10000 # 连接超时时间(ms)
  ReadTimeout: 10000 # 通信超时时间(ms)
```

前端的表单，添加action、method，给所有input标签设置对应的name，并且添加一个p标签，用于显示注册出错时的信息：

```html
<form action="/auth/member/do/register.html"  method="post" class="form-signin" role="form">
    <h2 class="form-signin-heading"><i class="glyphicon glyphicon-log-in"></i> 用户注册</h2>
    <p th:text="${message}"></p>
    <div class="form-group has-success has-feedback">
        <input type="text" name="loginAcct" class="form-control" id="inputSuccess4" placeholder="请输入登录账号" autofocus>
        <span class="glyphicon glyphicon-user form-control-feedback"></span>
    </div>
    <div class="form-group has-success has-feedback">
        <input type="text" name="userPswd" class="form-control" id="inputSuccess4" placeholder="请输入登录密码" style="margin-top:10px;">
        <span class="glyphicon glyphicon-lock form-control-feedback"></span>
    </div>
    <div class="form-group has-success has-feedback">
        <input type="text" name="userName" class="form-control" id="inputSuccess4" placeholder="请输入用户昵称" style="margin-top:10px;">
        <span class="glyphicon glyphicon-lock form-control-feedback"></span>
    </div>
    <div class="form-group has-success has-feedback">
        <input type="text" name="email" class="form-control" id="inputSuccess4" placeholder="请输入邮箱地址" style="margin-top:10px;">
        <span class="glyphicon glyphicon glyphicon-envelope form-control-feedback"></span>
    </div>
    <div class="form-group has-success has-feedback">
        <input type="text" name="phoneNum" class="form-control" id="inputSuccess4" placeholder="请输入手机号" style="margin-top:10px;">
        <span class="glyphicon glyphicon glyphicon-earphone form-control-feedback"></span>
    </div>
    <div class="form-group has-success has-feedback">
        <input type="text" name="code" class="form-control" id="inputSuccess4" placeholder="请输入验证码" style="margin-top:10px;">
        <span class="glyphicon glyphicon glyphicon-comment form-control-feedback"></span>
    </div>
    <button type="button" id="sendBtn" class="btn btn-lg btn-success btn-block"> 获取验证码</button>
    <button type="submit" class="btn btn-lg btn-success btn-block">注册</button>
</form>
```

**==远程方法调用记得保持API模块中的 方法 、和@RequestMapping中的 参数 、与 MySQL模块中的保持一致，后面不再特意提及==**

crowdfunding17-member-api：

```java
@FeignClient("crowd-mysql")
public interface MySQLRemoteService {

    @RequestMapping("/get/member/by/login/acct/remote")
    ResultEntity<MemberPO> getMemberPOByLoginAcctRemote(@RequestParam("loginacct") String loginacct);

    @RequestMapping("/save/member/remote")
    ResultEntity<String> saveMemberRemote(@RequestBody MemberPO memberPO);
}
```

crowdfunding10-member-mysql-provider：

```java
@RestController
public class MemberProviderHandler {

    @Autowired
    MemberService memberService;

    @RequestMapping("/get/member/by/login/acct/remote")
    public ResultEntity<MemberPO> getMemberPOByLoginAcctRemote(@RequestParam("loginacct") String loginacct){
        try {
            MemberPO memberPO = memberService.getMemberPOByLoginAcct(loginacct);
            return ResultEntity.successWithData(memberPO);
        } catch (Exception e){
            e.printStackTrace();
            return ResultEntity.failed(e.getMessage());
        }
    }

    @RequestMapping("/save/member/remote")
    public ResultEntity<String> saveMemberRemote(@RequestBody MemberPO memberPO){
        try {
            memberService.saveMember(memberPO);
            return ResultEntity.successWithoutData();
        } catch (Exception e){
            if (e instanceof DuplicateKeyException){
                return ResultEntity.failed(CrowdConstant.MESSAGE_SYSTEM_ERROR_LOGIN_NOT_UNIQUE);
            }
            return ResultEntity.failed(e.getMessage());
        }
    }
}
```

注册功能实现完成。

### ==坑==

①依赖的重复调用，需要自己==捋清楚模块之间的依赖关系==，jar包之间的依赖冲突可以通过插件排除

②调用第三方的短信接口要看清楚参数的填写（比如在做案例时code的参数值是"code:"+code）里面的**"code："**不能漏掉



# 会员登录

## 目标

检查账号密码正确后将用户信息存入Session，表示用户已登录

## 思路

![前台会员登录](https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220610214143785.png)



## 实现

#### MemberLoginVO

```java
@AllArgsConstructor
@NoArgsConstructor
@Data
public class MemberLoginVO {
    private Integer id;

    private String userName;

    private String email;

}
```

#### MemberController

```java
// 登录操作
@RequestMapping("/auth/member/do/login.html") // 表单登录的action
public String doLogin(@RequestParam("loginAcct") String loginAcct, @RequestParam("loginPswd") String loginPswd, ModelMap modelMap, HttpSession session) {
    // 1、调用远程接口，根据登录账号查询MemberPO对象
    ResultEntity<MemberPO> resultEntity = mySQLRemoteService.getMemberPOByLoginAcctRemote(loginAcct);

    // 2、判断-查询操作是否成功
    if (ResultEntity.FAILED.equals(resultEntity.getOperationResult())) {
        // 查询失败，返回登录界面
        modelMap.addAttribute(CrowdConstant.ATTR_NAME_MESSAGE, resultEntity.getOperationMessage());
        return "member-login";
    }
    // 3、查询操作成功，则取出MemberPO对象
    MemberPO memberPO = resultEntity.getQueryData();

    // 判断下得到的memberPO是否为空
    if (memberPO == null) {
        // 为空则返回登录页面
        return "member-login";
    }
    // 返回的MemberPO非空，取出数据库中的密码（已经加密的）
    String userPswd = memberPO.getUserPswd();

    // 使用BCryptPasswordEncoder，比对表单的密码与数据库中的密码是否匹配
    BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder();
    boolean matches = bCryptPasswordEncoder.matches(loginPswd, userPswd);

    // 密码不同
    if (!matches) {
        // 返回登陆页面，存入相应的提示信息
        modelMap.addAttribute(CrowdConstant.ATTR_NAME_MESSAGE, CrowdConstant.MESSAGE_LOGIN_FAILED);
        return "member-login";
    }
    // 密码匹配，则通过一个MemberLoginVO对象，存入需要在session域通信的用户信息
    // （只在session域放一些相对不私秘的信息，保护用户隐私）
    MemberLoginVO loginMember = new MemberLoginVO(memberPO.getId(), memberPO.getUserName(), memberPO.getEmail());

    // 将LoginMemberVO对象存入session域
    // (因为session会放入redis，因此LoginMemberVO必须实现序列化)
    session.setAttribute(CrowdConstant.ATTR_NAME_LOGIN_MEMBER, loginMember);

    // 重定向到登陆成功后的主页面（由于在zuul中设置了sensitive-headers，所以请求头不变）
    return "redirect:/auth/member/to/center/page.html";
}
```

**==因为session会放入redis，因此LoginMemberVO必须实现序列化==**

![image-20220611235200283](https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220611235200283.png)

其中的bCryptPasswordEncoder.matches（）方法

![image-20220610222253625](https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220610222253625.png)

> 注意要数据库中加密保存的密码，普通的没有用

#### 退出登录

```java
// 退出登录
@RequestMapping("auth/do/member/logout.html")
public String doLogout(HttpSession session) {
    // 清楚session域数据
    session.invalidate();

    // 重定向到首页
    return "redirect:/";
}
```



## 会员登录功能延伸

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220610232637567.png" alt="image-20220610232637567" style="zoom:67%;" />**springboot内置的Tomcat**                        

Session不互通，有些功能要求登录后才能使用，因此在Zuul中配置登录检查

使用Session共享技术解决



#### 会话控制回顾

回顾以前学的 cookie 和 session 都有笔记

##### (1) Cookie 的工作机制

```
服务器端返回 Cookie 信息给浏览器
       Java 代码：response.addCookie(cookie 对象);
       HTTP 响应消息头：Set-Cookie: Cookie 的名字=Cookie 的值

浏览器接收到服务器端返回的 Cookie，以后的每一次请求都会把 Cookie 带上
      HTTP 请求消息头：Cookie: Cookie
```

##### **(2) Session 的工作机制**

```
获取 Session 对象：request.getSession()
检查当前请求是否携带了 JSESSIONID 这个 Cookie
          带了：根据这个 JSESSIONID 在服务器端查找对应的 Session 对象
                能找到：就把找到的 Session 对象返回
                没找到：新建Session 对象返回，同时返回 JSESSIONID 的 Cookie
         没带：新建 Session 对象返回，同时返回JSESSIONID 的 Cookie
```

##### Session 共享

```
在分布式和集群环境下，每个具体模块运行在单独的 Tomcat 上，而 Session 是被不同Tomcat 所“区隔”的，所以不能互通，会导致程序运行时，用户会话数据发生错误。有的服务器上有，有的服务器上没有。
```

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220610235718532.png" alt="image-20220610235718532" style="zoom:67%;" />

#### 解决方案

##### （1）Session 同步(不可取)

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220611002314280.png" alt="image-20220611002314280" style="zoom:50%;" />

- 问题1：造成Session 在各个服务器上“同量”保存。

  TomcatA 保存了1G的Session 数据，TomcatB 也需要保存1G 的Session 数据。

  数据量太大的话会导致Tomcat 性能下降。

- 问题2：数据同步对性能有一定影响。



##### （2）将Session 数据存储在Cookie 中(不可取)

做法：所有会话数据在**浏览器端**使用Cookie 保存，服务器端不存储任何会话数据。

- 好处：

  - 服务器端大大减轻了数据存储的压力。不会有Session 不一致问题。

- 缺点：

  - Cookie 能够存储的数据非常有限。一般是**4KB**。不能存储丰富的数据。

  - Cookie 数据在浏览器端存储，很大程度上不受服务器端控制，

    如果浏览器端清理Cookie，相关数据会丢失。

##### （3）反向代理hash 一致性(不可取)

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220611112332563.png" alt="image-20220611112332563" style="zoom:67%;" />

- 问题1：具体一个浏览器，**专门**访问某一个具体服务器，如果服务器宕机，会**丢失数据**。存在**单点故障**风险。
- 问题2：**仅仅适用于集群范围内，超出集群范围，负载均衡服务器无效。**



##### ==（4）后端统一存储Session 数据==

后端存储Session 数据时，一般需要使用Redis 这样的**内存**数据库，而一般不采用MySQL 这样的关系型数据库。

原因如下：

- Session 数据存取比较频繁。内存访问速度快。

- Session 有过期时间，Redis 这样的内存数据库能够比较方便实现过期释放。

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220611112712035.png" alt="image-20220611112712035" style="zoom:50%;" />

优点：

- 访问速度比较快。虽然需要经过网络访问，但是现在硬件条件已经能够达到网络访问比硬盘访问还要快。
  - 硬盘访问速度：200M/s
  - 网络访问速度：1G/s
- Redis 可以配置主从复制集群，不担心**单点故障**。



##### 扩展

![image-20220611004809555](https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220611004809555.png)

#### SpringSession 

> spring boot环境

概括：**SpringSession 从底层全方位“接管”了Tomcat 对Session 的管理。**

![image-20220611210435760](https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220611210435760.png)

**SessionRepositoryFilter**

利用**Filter** 原理， 在每次请求到达目标方法之前， 将原生**HttpServletRequest/HttpServletResponse** 对象包装为**SessionRepositoryRequest/ResponseWrapper**。包装request 对象时要做到：包装后和包装前类型容。所谓类型兼容：“包装得到的对象instanceof 包装前类型”返回true。只有做到了类型的兼容，后面使用包装过的对象才能够保持使用方法不变。包装过的对象类型兼容、使用方法不变，才能实现“偷梁换柱”。但是如果直接实现HttpServletRequest 接口，我们又不知道如何实现各个抽象方法。这个问题可以借助原始被包装的对象来解决。

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220611210720052.png" alt="image-20220611210720052" style="zoom:50%;" />

> 下面是正式操作
>
> 

## 登录检查

#### 目标

把项目中必须登录才能访问的功能保护起来，如果没有登录就访问则跳转到登录页面。

#### 思路

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220611212328185.png" alt="image-20220611212328185" style="zoom:50%;" />

#### 实现

##### ① Session共享

在分布式和集群的环境下，每一个模块运行在各自的单独的Tomcat服务器上，而Session被不同的Tomcat隔离，因此无法互通，导致程序运行时会发生数据不互通的情况。

针对这个问题，这边采用后端统一存储Session数据的方法——将Session数据存入到Redis中（这样速度比MySQL更快）

Spring也提供了此工具：**spring-session**

**spring-session**的依赖：

```xml
<dependency>
    <groupId>org.springframework.session</groupId>
    <artifactId>spring-session-data-redis</artifactId>
</dependency>
```

同时因为使用**redis**存储session，也需要引入redis的依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

此处先给crowdfunding12-member-authentication-consumer与crowdfunding16-member-zuul模块加上了**spring-session和redis**的相关依赖。

在**两处的application.yml文件**中都配置：

```yml
spring:
  # 设置redis服务器的ip
  redis:
    host: 172.18.41.29
  # 设置spring-session的存储方式为存入redis中
  session:
    store-type: redis
```

此时两个微服务之间的session可以进行互通了。

## ==登录验证==

##### **先在util工程中设置好可以放行的内容：**

**judgeIsStaticResource方法判断是否是静态资源**

```java
package com.x.crowd.constant;

import java.util.HashSet;
import java.util.Set;

/**
 * @Author: x
 * @CreateTime: 2022-06-11  21:35
 * @Description: TODO
 * @Version: 1.0
 */
public class AccessPassResources {
    // 保存不被过滤的请求
    public static final Set<String> PASS_RES_SET = new HashSet<>();


    // 静态代码块中加入不被过滤的路径
    static {
        PASS_RES_SET.add("/");
        PASS_RES_SET.add("/auth/member/to/reg/page.html");
        PASS_RES_SET.add("/auth/member/to/login/page.html");
        PASS_RES_SET.add("/auth/member/send/short/message.json");
        PASS_RES_SET.add("auth/member/do/register.html");
        PASS_RES_SET.add("auth/member/do/login.html");
        PASS_RES_SET.add("auth/do/member/logout.html");
        PASS_RES_SET.add("/error");
        PASS_RES_SET.add("/favicon.ico");
    }

    // 保存不被过滤的静态资源
    public static final Set<String> STATIC_RES_SET = new HashSet<>();

    static {
        STATIC_RES_SET.add("bootstrap");
        STATIC_RES_SET.add("css");
        STATIC_RES_SET.add("fonts");
        STATIC_RES_SET.add("img");
        STATIC_RES_SET.add("jquery");
        STATIC_RES_SET.add("layui");
        STATIC_RES_SET.add("script");
        STATIC_RES_SET.add("ztree");
    }

    /**
     * @param servletPath 当前请求的路径  就是localhost:8080/aaa/bbb/ccc中的 “aaa/bbb/ccc”
     * @return true: 表示该资源是静态资源; false: 表示该资源不是静态资源
     */
    public static boolean judgeIsStaticResource(String servletPath){

        // 先判断字符串是否为空
        if (servletPath == null || servletPath.length() == 0){
            throw new RuntimeException(CrowdConstant.MESSAGE_STRING_INVALIDATE);
        }

        // 通过“/”来分割得到的请求路径
        String[] split = servletPath.split("/");

        // split[0]是一个空字符串，因此取split[1]，相当于/aaa/bbb/ccc的“aaa”
        String path = split[1];

        // 判断是否包含得到的请求的第一个部分
        return STATIC_RES_SET.contains(path);
    }

}
```

##### 登录验证操作交给ZuulFilter的子类（自己实现）来完成：

```java
// 加入ioc容器
@Component
public class AssessFilter extends ZuulFilter {

    // return "pre" 表示在请求发生其前进行过滤
    @Override
    public String filterType() {
        return "pre";
    }

    @Override
    public int filterOrder() {
        return 0;
    }

    /**
     * @return true:表示被拦截; false: 表示放行
     */
    @Override
    public boolean shouldFilter() {

        // 通过getCurrentContext得到当前的RequestContext
        RequestContext requestContext = RequestContext.getCurrentContext();

        // 通过RequestContext得到HttpServletRequest
        HttpServletRequest request = requestContext.getRequest();

        // 获得当前请求的路径
        String servletPath = request.getServletPath();

        // 判断当前请求路径是否包含在不被过滤的请求的set集合中
        boolean isPassContains = AccessPassResources.PASS_RES_SET.contains(servletPath);

        // 如果包含在set中，返回false，表示不被过滤
        if (isPassContains) {
            return false;
        }

        // 判断是否是静态资源
        boolean isStaticResource = AccessPassResources.judgeIsStaticResource(servletPath);

        // 是静态资源则工具方法返回true，因为应该放行，所以取反，返回false
        return !isStaticResource;
    }

    @Override
    public Object run() throws ZuulException {

        // 通过getCurrentContext得到当前的RequestContext
        RequestContext requestContext = RequestContext.getCurrentContext();

        // 通过RequestContext得到HttpServletRequest
        HttpServletRequest request = requestContext.getRequest();

        // 得到session
        HttpSession session = request.getSession();

        // 从session中得到“loginMember”
        Object loginMember = session.getAttribute(CrowdConstant.ATTR_NAME_LOGIN_MEMBER);

        // 判断得到的loginMember是否为空
        if (loginMember == null) {
            // 为空 取得response，为了后面进行重定向
            HttpServletResponse response = requestContext.getResponse();

            // 向session域中存放"message":"还未登录，禁止访问受保护资源！",为了在重定向后能够在前台显示错误信息
            session.setAttribute(CrowdConstant.ATTR_NAME_MESSAGE, CrowdConstant.MESSAGE_ACCESS_FORBIDDEN);

            try {
                // 重定向到登录页面
                response.sendRedirect("/auth/to/member/login/page.html");
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        // 返回null就是不操作
        return null;
    }
}
```

这里Zuul模块中的application.yml一定要设置 **sensitive-headers: "*"**，保持原有的头信息，否则重定向后重新创建了request、response对象，就无法携带session的信息了 ：

```yml
zuul:
  ignored-services: "*"       # 表示忽视直接通过application-name访问微服务，必须通过route
  sensitive-headers: "*"      # 在Zuul向其他微服务重定向时，保持原本的头信息（请求头、响应头）
  routes:                     # 指定网关路由
    crowd-protal:
      service-id: crowd-auth  # 对应application-name
      path: /**               # 表示直接通过根路径访问，必须加上**，否则多层路径无法访问
```

##### ==**细节：**==

**1）**用**zuul**做登录拦截的时候发现并没有起到拦截的作用，检查zuul的shouldFilter()方法也发现始终没有被调用，最后发现是浏览器输入的url地址的问题，因为使用的是**localhost+端口号**的方式访问的，导致一直在直接调消费者服务，而不是**从网关这边开始调用**，**导致网关并没有起到作用**。

例如：http://localhost:4000 与 http://localhost:80 是两个不同的网站，浏览器不会使用相同的cookie

> **解决如下**

**2）**分布式项目中**重定向**问题

在两个不同的网站，浏览器工作时不会使用相同的cookie，也就使**不同微服务之间**无法很好地同步数据。因此分布式项目中重定向时，需要带上**前缀**：这里使用Zuul，且端口号为80，因此可以看到上面crowdfunding12-member-authentication-consumer模块的代码中的重定向都是转发到localhost上，类似：

 ```java
 return "redirect:http://localhost/xxx/xxx"; // 此处没有配置域名所以用的localhost，端口默认80
 												(即走的网关)
 ```

redirect：后面可接域名（配置文件或借助工具设置域名）

**3）ClassNotFound异常处理**

**Zuul必须引入crowdfunding09-member-entity的依赖，否则会出现反序列化LoginMemberVO对象时ClassNotFounding的异常**



## 从个人中心跳转到发起项目的页面：

```html
<div class="list-group-item " style="cursor:pointer;">
    <a th:href="@{/auth/member/to/crowd/page.html}" style="text-decoration: none">我的众筹</a>
    <span class="badge"><i class="glyphicon glyphicon-chevron-right"></i></span>
</div>
```

通过**view-controller**跳转到member-crowd.html页面。

完善跳转的代码、以及对登录用户昵称的显示，这里都和member-center.html页面类似



# 阿里云的OSS 对象存储

## 问题

**以前上传文件时保存位置**

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220612104720225.png" alt="image-20220612104720225" style="zoom: 67%;" />实质上还是部署在Tomcat上

**问题1：Web 应用重新部署导致文件丢失。**

重新部署Web 应用时，卸载（删除）旧的Web 应用，连同用户上传的文件一起删除。重新加载新的Web 应用后以前用户上传的文件不会自动恢复。

**问题2：集群环境下文件难以同步**

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220612105426177.png" alt="image-20220612105426177" style="zoom: 67%;" />要是上传和下载访问的是不同的Tomcat,发现没有同步

**问题3：Tomcat 被拖垮**

用户上传的文件如果数据量膨胀到了一个非常庞大的体积，那么就会严重影响Tomcat 的运行效率。

**问题4：服务器存储自动扩容问题**

java程序——>上传到服务器A（ip1）——>服务器扩容（硬盘有限）——>另一个服务器B（ip2） 

此时ip就改变了，程序也要更改并重新部署

**危害总结：手动对服务器进行扩容，有可能导致项目中其他地方需要进行连带修改。**

> 扩展：FastFDS：一个开源的轻量级[分布式文件系统](https://baike.baidu.com/item/分布式文件系统/1250388)，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和[负载均衡](https://baike.baidu.com/item/负载均衡/932451)的问题

## 解决方案

1 自己搭建文件服务器

- 举例：FastDFS

- 好处：**服务器可以自己维护、自己定制**。
- 缺点：需要投入的人力、物力更多。
- 适用：**规模比较大**的项目，要存储海量的文件。

2 使用第三方云服务

- 举例：阿里云提供的OSS 对象存储服务。
- 好处：**不必自己维护服务器的软硬件资源**。直接调用相关API 即可操作，更加轻量级。
- 缺点：数据不在自己手里。服务器不由自己维护。
- 适用：**较小规模**的应用，文件数据不是绝对私密。



## OSS使用

#### 创建Bucket

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220612164743896.png" alt="image-20220612164743896" style="zoom:67%;" />

#### 在bucket中创建目录

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220612164850157.png" alt="image-20220612164850157" style="zoom:67%;" />

#### 上传文件测试

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220612165156867.png" alt="image-20220612165156867" style="zoom:67%;" />

**浏览器访问文件路径组成**

![image-20220612165921165](https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220612165921165.png)

### ==Java 程序调用OSS 服务接口==

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220612171922091.png" alt="image-20220612171922091" style="zoom:67%;" />

**官方介绍**

阿里云对象存储服务（Object Storage Service，简称OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以通过调用API，在任何应用、任何时间、任何地点上传和下载数据，也可以通过Web 控制台对数据进行简单的管理。OSS 适合存放任意类型的文件，适合各种网站、开发企业及开发者使用。按实际容量付费真正使您专注于核心业务。

#### 创建AccessKey

#### ①介绍

阿里云账号、密码→登录后在网页上操作

AccessKey→Java 程序登录OSS 进行操作

> **访问密钥AccessKey（AK）**相当于**登录密码**，只是使用场景不同。AccessKey 用于程序方式调用云服务API，而登录密码用于登录控制台。如果您不需要调用API，那么就不需要创建AccessKey。
> 您可以使用**AccessKey 构造一个API 请求（或者使用云服务SDK）来操作资源**。
>
> AccessKey 包括AccessKeyId 和AccessKeySecret。
>
> **AccessKeyId** 用于标识用户，相当于账号。
> **AccessKeySecret** 是用来验证用户的密钥。AccessKeySecret 必须保密。
>
> ==警告：==禁止使用主账号AK，因为主账号AK泄露会威胁您所有资源的安全。请使用子账号（RAM
> 用户）AK 进行操作，可有效降低AK 泄露的风险。

#### ②创建子账号AK 的操作步骤

1.使用主账号登录RAM 管理控制台。

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220612172627755.png" alt="image-20220612172627755" style="zoom: 67%;" /><img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220612172731251.png" alt="image-20220612172731251" style="zoom:50%;" />

2.如果未创建RAM 用户，在左侧导航栏，单击用户管理，然后单击新建用户，创建RAM 用户。如果已创建RAM 用户，跳过此步骤。

3.在左侧导航栏，单击用户，创建用户然后单击需要创建AccessKey 的用户名，进入用户详情页面。

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220612173026272.png" alt="image-20220612173026272" style="zoom: 50%;" />



4.在用户AccessKey 区域，单击创建AccessKey。

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220612173301977.png" alt="image-20220612173301977" style="zoom:50%;" />



5.完成手机验证后，在新建用户AccessKey 页面，展开AccessKey 详情，查看AcessKeyId 和AccessKeySecret。然后单击保存AK 信息，下载AccessKey 信息。

##### **信息：**

用户登录名称 cosky220612oss@1742451463265651.onaliyun.com
**AccessKey ID**  LTAI5tCp8eAuuiV1q6gDsByN
<font color = red>**AccessKey Secret** </font>weKAFY0pg3bdgrmwrTskep3Z3aldSp

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220612173256894.png" alt="image-20220612173256894" style="zoom:50%;" />

注意AccessKey 创建后，无法再通过控制台查看。请您妥善保存AccessKey，谨防泄露。



6.单击该RAM 用户对应的授权，给RAM 用户授予相关权限，例如AliyunOSSFullAccess 将给RAM 用户授予OSS 的管理权限。

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220612174034016.png" alt="image-20220612174034016" style="zoom:67%;" />



**SDK 参考（kit：配套元件）**
**JDK：Java Development Kit**
**SDK：Software Development Kit**

![image-20220612174346956](https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220612174346956.png)

java接收的是输入流

### 将OSS 引入项目

##### ①准备OSSProperties 类

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220612175913683.png" alt="image-20220612175913683" style="zoom:50%;" />

```java
import org.springframework.stereotype.Component;

/**
 * @Author: x
 * @CreateTime: 2022-06-12  17:54
 * @Description: TODO
 * @Version: 1.0
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Component
@ConfigurationProperties(prefix = "aliyun.oss")
public class OSSProperties {
    private String endPoint;
    private String bucketName;
    private String accessKeyId;
    private String accessKeySecret;
    private String bucketDomain;
}
```

加入依赖：

```xml
       <dependency>
            <groupId>com.aliyun.oss</groupId>
            <artifactId>aliyun-sdk-oss</artifactId>
            <version>3.15.0</version>
        </dependency>
```

##### ②将OSS 代码中用到的属性存入yml 配置文件

```yml
aliyun:
  oss:
    access-key-id: LTAI5tCp8eAuuiV1q6gDsByN
    access-key-secret: weKAFY0pg3bdgrmwrTskep3Z3aldSp
    bucket-domain: cosky220612.oss-cn-shenzhen.aliyuncs.com
    bucket-name: cosky220612
    end-point: oss-cn-shenzhen.aliyuncs.com
```

##### ③创建工具方法

也需加入依赖

```xml
  <dependency>
        <groupId>com.aliyun.oss</groupId>
        <artifactId>aliyun-sdk-oss</artifactId>
        <version>3.15.0</version>
    </dependency>
```

**CrowUtil：**

```java
/**
 * 专门负责上传文件到OSS 服务器的工具方法
 *
 * @param endpoint        OSS 参数
 * @param accessKeyId     OSS 参数
 * @param accessKeySecret OSS 参数
 * @param inputStream     要上传的文件的输入流
 * @param bucketName      OSS 参数
 * @param bucketDomain    OSS 参数
 * @param originalName    要上传的文件的原始文件名
 * @return 包含上传结果以及上传的文件在OSS 上的访问路径
 */
public static ResultEntity<String> uploadFileToOss(
        String endpoint,
        String accessKeyId,
        String accessKeySecret,
        InputStream inputStream,
        String bucketName,
        String bucketDomain,
        String originalName) {
    // 创建OSSClient 实例。
    OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);
    // 生成上传文件的目录
    String folderName = new SimpleDateFormat("yyyyMMdd").format(new Date());
    // 生成上传文件在OSS 服务器上保存时的文件名
    // 原始文件名：beautfulgirl.jpg
    // 生成文件名：wer234234efwer235346457dfswet346235.jpg
    // 使用UUID 生成文件主体名称
    String fileMainName = UUID.randomUUID().toString().replace("-", "");
    // 从原始文件名中获取文件扩展名
    String extensionName = originalName.substring(originalName.lastIndexOf("."));
    // 使用目录、文件主体名称、文件扩展名称拼接得到对象名称
    String objectName = folderName + "/" + fileMainName + extensionName;
    try {
        // 调用OSS 客户端对象的方法上传文件并获取响应结果数据
        PutObjectResult putObjectResult = ossClient.putObject(bucketName, objectName,
                inputStream);
        // 从响应结果中获取具体响应消息
        ResponseMessage responseMessage = putObjectResult.getResponse();
        // 根据响应状态码判断请求是否成功
        if (responseMessage == null) {
            // 拼接访问刚刚上传的文件的路径
            String ossFileAccessPath = bucketDomain + "/" + objectName;
            // 当前方法返回成功
            return ResultEntity.successWithData(ossFileAccessPath);
        } else {
            // 获取响应状态码
            int statusCode = responseMessage.getStatusCode();
            // 如果请求没有成功，获取错误消息
            String errorMessage = responseMessage.getErrorResponseAsString();
            // 当前方法返回失败
            return ResultEntity.failed(" 当前响应状态码=" + statusCode + " 错误消息 = "+errorMessage);
        }
    } catch (Exception e) {
        e.printStackTrace();
        // 当前方法返回失败
        return ResultEntity.failed(e.getMessage());
    } finally {
        if (ossClient != null) {
            // 关闭OSSClient。
            ossClient.shutdown();
        }
    }
}
```

> 生成上传文件的目录：按上传时间创建目录。文件名用UUID

