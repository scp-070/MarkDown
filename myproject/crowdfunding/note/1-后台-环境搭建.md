目标:arrow_right:思路:arrow_right:编码

# 一、技术选型

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220505105958251.png" alt="image-20220505105958251" style="zoom:67%;" />

# 二、架构

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220505171715026.png" alt="image-20220505171715026" style="zoom: 67%;" />

**各模块间的依赖关系**

- webui 依赖component

- component 依赖entity

- component 依赖util

  <img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220506000918066.png" alt="image-20220506000918066" style="zoom:50%;" />

  在idea中添加方式：

  ##### ![image-20220505172206911](https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220505172206911.png)



# 三、环境搭建

## 1）数据库

#### 物理建模

**相关理论**：

- **第一范式**：数据库表中的每一列都不可再分，也就是==原子性==

  ![image-20220505205617896](https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220505205617896.png)

  这个表中“部门”和“岗位”应该拆分成两个字段：“部门名称”、“岗位”。才能针对部门或岗位进行查询

  ![image-20220505205601821](https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220505205601821.png)

  

- **第二范式**：在满足第一范式基础上要求每个字段都和主键==完整==相关，而不是仅和主键部分相关（主要针对联合主键而言）

  <img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220505205633137.png" alt="image-20220505205633137" style="zoom:67%;" />

  “订单详情表”使用“订单编号”和“产品编号”作为**联合主键**。此时“产品价格”、“产品数量”都和联合主键整体相关，但“订单金额”和“下单时间”只和联合主键中的“订单编号”相关，和“产品编号”无关。所以只关联了主键中的部分字段，不满足第二范式。
  把“订单金额”和“下单时间”移到订单表就符合第二范式了。

  <img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220505205920865.png" alt="image-20220505205920865" style="zoom:67%;" />

  

- **第三范式**：表中的非主键字段和主键字段==直接==相关，不允许间接相关

  ![image-20220505205935067](https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220505205935067.png)

  上面表中的“部门名称”和“员工编号”的关系是“员工编号”→“部门编号”→“部门名称”，

  **不是直接相关**。此时会带来下列问题：

  - 数据冗余：“部门名称”多次重复出现。

  - 插入异常：组建一个新部门时没有员工信息，也就无法单独插入部门
    信息。就算强行插入部门信息，员工表中没有员工信息的记录同样是
    非法记录。

  - 删除异常：删除员工信息会连带删除部门信息导致部门信息意外丢失。

  - 更新异常：哪怕只修改一个部门的名称也要更新多条员工记录。

    

正确的做法是：把上表拆分成两张表，以外键形式关联

![image-20220505211113456](https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220505211113456.png)

“部门编号”和“员工编号”是直接相关的。
第二范式的另一种表述方式是：两张表要通过外键关联，不保存冗余字段。

例如：不能在“员工表”中存储“部门名称”。



**实际开发中**

- 规则的变通三大范式是设计数据库表结构的规则约束，但是在实际开发中允许局部变通

  比如为了快速查询到关联数据可能会允许冗余字段的存在。例如在员工表
  中存储部门名称虽然违背第三范式，但是免去了对部门表的关联查询。

- 根据业务功能设计数据库表

  - 看得见的字段

    ​	能够从需求文档或原型页面上直接看到的数据都需要设计对应的数据库表、字段来存储。
  
- 看不见的字段
  
  ​	除了能够直接从需求文档中看到的字段，实际开发中往往还会包含一些其他字段来保存其他相关数据。
    例如：管理员表需要再增加如下字段以有利于数据维护
  
  - 主键
    - 创建时间
  
- 冗余字段
  
  为了避免建表时考虑不周有所遗漏，到后期再修改表结构非常麻烦，所以也有的团队会设置一些额外的冗余字段备用。
  
- 实际开发对接
  
  实际开发中除了一些各个模块都需要使用的公共表在项目启动时创建好，其他专属于各个模块的表由该模块的负责人创建。但通常开发人员不能直接操作数据库服务器，所以需要把建表的SQL 语句发送给运维工程师执行创建操作。
  


### 创建Mybatis逆向工程

- 导入依赖

  ```xml
   <!-- 依赖MyBatis核心包 -->
      <dependencies>
          <dependency>
              <groupId>org.mybatis</groupId>
              <artifactId>mybatis</artifactId>
              <version>3.5.7</version>
          </dependency>
      </dependencies>
      <!-- 控制Maven在构建过程中相关配置 -->
      <build>
          <!-- 构建过程中用到的插件 -->
          <plugins>
              <!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 -->
              <plugin>
                  <groupId>org.mybatis.generator</groupId>
                  <artifactId>mybatis-generator-maven-plugin</artifactId>
                  <version>1.3.0</version>
                  <!-- 插件的依赖 -->
                  <dependencies>
                      <!-- 逆向工程的核心依赖 -->
                      <dependency>
                          <groupId>org.mybatis.generator</groupId>
                          <artifactId>mybatis-generator-core</artifactId>
                          <version>1.3.2</version>
                      </dependency>
                      <!-- 数据库连接池 -->
                      <dependency>
                          <groupId>com.mchange</groupId>
                          <artifactId>c3p0</artifactId>
                          <version>0.9.2</version>
                      </dependency>
                      <!-- MySQL驱动 -->
                      <dependency>
                          <groupId>mysql</groupId>
                          <artifactId>mysql-connector-java</artifactId>
                          <version>8.0.28</version>
                      </dependency>
                  </dependencies>
              </plugin>
          </plugins>
      </build>
  ```

- 创建generatorConfig.xml文件（文件名必须是这个）

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE generatorConfiguration
          PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
          "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
  <generatorConfiguration>
      <!--
      targetRuntime: 执行生成的逆向工程的版本
      MyBatis3Simple: 生成基本的CRUD（清新简洁版）
      MyBatis3: 生成带条件的CRUD（奢华尊享版）
      -->
      <context id="DB2Tables" targetRuntime="MyBatis3">
          <commentGenerator>
              <!-- 是否去除自动生成的注释true:是;false:否-->
              <property name="suppressAllComments" value="true" />
          </commentGenerator>
  
          <!-- 数据库的连接信息 -->
          <jdbcConnection driverClass="com.mysql.cj.jdbc.Driver"
                          connectionURL="jdbc:mysql://localhost:3306/project_crowd"
                          userId="root"
                          password="0707">
          </jdbcConnection>
  
          <!-- 默认false，把JDBC DECIMAL 和NUMERIC 类型解析为Integer，为true 时把JDBC DECIMAL和NUMERIC
          类型解析为java.math.BigDecimal -->
          <javaTypeResolver>
              <property name="forceBigDecimals" value="false"/>
          </javaTypeResolver>
          
          <!-- targetProject:生成Entity 类的路径-->
          <javaModelGenerator targetProject=".\src\main\java"
                              targetPackage="com.x.crowd.entity">
              <!-- enableSubPackages:是否让schema 作为包的后缀-->
              <property name="enableSubPackages" value="false"/>
              <!-- 从数据库返回的值被清理前后的空格-->
              <property name="trimStrings" value="true"/>
          </javaModelGenerator>
  
          <!-- targetProject:XxxMapper.xml 映射文件生成的路径-->
          <sqlMapGenerator targetProject=".\src\main\java"
                           targetPackage="com.x.crowd.mapper">
              <!-- enableSubPackages:是否让schema 作为包的后缀-->
              <property name="enableSubPackages" value="false"/>
          </sqlMapGenerator>
          
          <!-- targetPackage：Mapper 接口生成的位置-->
          <javaClientGenerator type="XMLMAPPER"
                               targetProject=".\src\main\java"
                               targetPackage="com.x.crowd.mapper">
              <!-- enableSubPackages:是否让schema 作为包的后缀-->
              <property name="enableSubPackages" value="false"/>
          </javaClientGenerator>
          
          <!-- 数据库表名字和我们的entity 类对应的映射指定-->
          <table tableName="t_admin" domainObjectName="Admin"/>
      </context>
  </generatorConfiguration>
  ```

​		实体类记得加上构造器

**关于mapper.xml文件放在webui下的问题:**

WebUI 工程将来在Tomcat 上运行时，现在resources 目录下的资源会直接放在WEB-INF/classes 目录（也就是类路径）下，所以放在resources 目录下运行的时候更容易找到。		



## 2）父工程依赖管理

![image-20220506002255855](https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220506002255855.png)

在具体依赖中用$引用即可，用于保证版本一致（在springBoot中可以省去这些步骤，直接导入配置场景）



## 3）spring整合mybatis

**目标**：adminMapper 通过IOC 容器装配到当前组件中后，就可以直接调用它的方法，

​			享受到框架给我们提供的方便

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220506003849616.png" alt="image-20220506003849616" style="zoom: 67%;" />

**思路**(p20)：

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220506004129016.png" alt="image-20220506004129016" style="zoom: 67%;" />

**用的扫描包配置不是spring时的开启组件扫描context: component-scan**

### <font color = red>**注意**</font>

> **奢华版会多出一个实体类Example结尾的Java文件**
>
> **实体类**：一个实体类对应一张表，将每个字段封装成对象。
>
> **mapper接口**：采用这种方式生成的代码只包含了基础的sql方法（增删改查），但是不能按照特定的条件来执行sql。
>
> **实体类Example**：这个类里面拥有很多的带条件的sql方法，内置了一个Criteria类来设置条件。所以说，example类从某种程度上可以说是对实体类的一种补充，它的功能比实体类—实体类mapper的功能更多。 这个类是专门用来对单表来查询的，就相当于，对该单表的增删改查是脱离sql性质的，直接在**service层**就可以完成（当然这个sql是逆向已经生过的）
>
> 
>
> [mapper.xml文件]: https://blog.csdn.net/ueiun2_explore/article/details/106610948

**步骤：**

1. 在子工程中加入搭建环境所需要的具体依赖

   关于父子工程中的依赖引用问题

   - ==<dependencyManagement>==
     这里其实是起到管理依赖jar版本号的作用，一般只会在项目的最顶层的pom.xml中使用到，所有子module如果想要使用到这里面声明的jar，只需要在子module中添加相应的groupId和artifactId即可，并不需要声明版本号，需要注意的是这里面只是声明一个依赖，并不是真实的下载jar，只有在子module中使用到，才会去下载依赖。
   - `<dependencies>`
     我们是这里引入了一个jar包之后，这里如果没有加上version版本号的话，那么maven就会去`<dependencyManagement>`里找对应groupId和artifactId的jar,如果有就继承他，如果没有就会报错，这时候其实在我们配置的本地仓库中会真实的下载对应的jar包，这时候所有的子module都会默认继承这里面所有声明的jar

   总的来说，就是在中声明依赖和版本号，该标签中的依赖不会被子模块继承，仅仅是声明，子pom中直接引入依赖，具体的版本号会在父子中去找。

   具体看https://blog.csdn.net/weixin_46574898/article/details/122783616

   ***父工程声明了依赖子工程还需要引入吗？***  

   需要，只是不用管理版本了，由父工程统一管理，注意各依赖之间的版本匹配

   

2. 准备jdbc.properties

3. 创建Spring 配置文件 专门配置Spring 和MyBatis 整合相关<font color = red>(spring-persist-mybatis.xml)</font>

4. 在Spring 的配置文件 中加载jdbc.properties 属性文件

   ```xml
   <!--引入properties文件-->
   <context:property-placeholder location="classpath:jdbc.properties"/>
   ```

5. **配置数据源**

   ```xml
   <!--数据源配置-->
   <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
       <property name="username" value="${jdbc.user}"/>
       <property name="password" value="${jdbc.password}"/>
       <property name="url" value="${jdbc.url}"/>
       <property name="driverClassName" value="${jdbc.driver}"/>
   </bean>
   ```

6. 测试从数据源中获取数据库连接

   ![image-20220506144629384](https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220506144629384.png)

   

7. 配置SqlSessionFactoryBean

8. 装配数据源

9. 指定XxxMapper.xml 配置文件的位置

10. 指定MyBatis 全局配置文件的位置（可选）

    ```xml
    <!--配置SqlSessionFactoryBean（设置mybatis配置文件的路径、mapper.xml文件的路径、注入数据源）-->
    <bean class="org.mybatis.spring.SqlSessionFactoryBean" id="sqlSessionFactoryBean">
        <property name="configLocation" value="classpath:mybatis/mybatis-config.xml"/>
        <property name="mapperLocations" value="classpath:mybatis/mapper/*.xml"/>
        <property name="dataSource" ref="dataSource"/>
     <!--配置插件-->
            <property name="plugins">
                <array>
                    <!--配置PageHelper，用于帮助分页-->
                    <bean class="com.github.pagehelper.PageHelper">
                        <property name="properties">
                            <props>
                                <!--设置数据库方言（这里就是mysql）-->
                                <prop key="dialect">mysql</prop>
                                <!--让PageHelper自动将浏览器传来的PageNum修正到正确范围-->
                                <prop key="reasonable">true</prop>
                            </props>
                        </property>
                    </bean>
    ```

    **==注意mapper.xml文件中namespace的包一定要填写正确，与11的相对应==**

11. **配置MapperScannerConfigurer==(注意包的值)==**

    ```xml
    <!--配置与mapper.xml对应的mapper接口的包路径-->
    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <property name="basePackage" value="com.x.crowd.mapper"/>
    </bean>
    ```

12. 测试是否可以装配XxxMapper 接口并通过这个接口操作数据库

    ```java
     @Autowired
        private DataSource dataSource;
        
         @Test
        public void testConnection() throws SQLException {
            Connection connection = dataSource.getConnection();
            System.out.println(connection);
        }
    ```



## 4）日志

将原生的（spring默认使用的）**commons-logging**去掉，用**jcl-over-slf4j.jar**（转换包）代替。它会将spring对原有（日志）接口的调用改成对**slf4j-api.jar**的调用，slf4j-api.jar再去调用**logback-classic.jar**.

```java
@Test
public void testLog(){
    //获取Logger对象，这里传入的Class就是当前打印日志的类
    Logger logger = LoggerFactory.getLogger(CrowTest.class);
    //等级 DEBUG < INFO < WARN < ERROR
}

```

**idea排除依赖技巧**：新版idea添加了*依赖分析器*功能，可以对项目中的依赖信息进行检索，检测和解决冲突的依赖项，过滤掉相同的依赖项并检查它们是否存在于不同的库中，并轻松地跨依赖项导航以正确构建配置

![](https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220506175510485.png)

**配置logback.xml设置logback工作时的具体细节**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration debug="true">
    <!-- 指定日志输出的位置-->
    <appender name="STDOUT"
              class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <!--日志输出的格式-->
            <!--按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行-->
            <pattern>[%d{HH:mm:ss.SSS}]  [%-5level] [%thread] [%logger] [%msg]%n</pattern>
        </encoder>
    </appender>
    <!--设置全局日志级别。日志级别按顺序分别是： DEBUG、 INFO、 WARN、 ERROR-->
    <!--指定任何一个日志级别都只打印当前级别和后面级别的日志。-->
    <root level="INFO">
        <!--指定打印日志的 appender 这里通过 “STDOUT”引用了前面配置的 appender-->
        <appender-ref ref="STDOUT"/>
    </root>
    <!-- 根据特殊需求指定局部日志级别-->
    <logger name="com.x.crowd.mapper" level="DEBUG"/>
</configuration>
```



## 5）声明式事务

从事务角度：一个事务方法中包含的多个数据库操作，要么一起提交、要么一起回滚。也就是说事务方法中的多个数据库操作，有任何一个失败，整个事务全部回滚。

从声明式角度：由Spring来全面接管数据库事务。用声明式代替编程式。

```java
try {
// 核心操作前：开启事务（关闭自动提交）
// 对应 AOP的前置通知
connection.setAutoCommit(false);
// 核心操作
adminService.updateXxx(xxx, xxx);
// 核心操作成功：提交事务
// 对 应 AOP的返回通知
connection.commit();
}catch(Exception e){
// 核心操作失败：回滚事务
// 对应 AOP的异常通知
connection.rollBack();
}finally{
// 不论成功还是失败，核心操作终归是结束了
// 核心操作不管是怎么结束的，都需要释放数据库连接
// 对应 AOP的后置通知
if(connection != null){
connection.close();
}
}
```

**思路**（p34）

![image-20220506204620420](https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220506204620420.png)

**加入依赖**

```xml
<!--AOP所需依赖-->
<dependency>
<groupId>org.aspectj</groupId>
<artifactId>aspectjweaver</artifactId>
</dependency>
<dependency>
<groupId>cglib</groupId>
<artifactId>cglib</artifactId>
</dependency>
```

**创建配置文件spirng-persist-tx**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

    <!--【①组件扫描】将com.service包中的组件扫描入容器-->
    <context:component-scan base-package="com.x.crowd.service"/>

    <!--【②配置事务管理器】-->
    <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <!--装配数据源-->
        <property name="dataSource" ref="dataSource"/><!--爆红但是一般没影响，可以加载就没问题-->
    </bean>

    <!--【④配置AOP(事务切面)】-->
    <aop:config>
        <!--配置切入点表达式-->
        <!--public void com.x.crowd.service.impl.adminServiceImpl(Admin admin)-->
        <!--[.. 任意的]-->
        <aop:pointcut id="txPointcut" expression="execution(* *..*ServiceImpl.*(..))"/>

        <!--关联事务通知与切入点-->
        <aop:advisor advice-ref="txAdvice" pointcut-ref="txPointcut"/>
    </aop:config>

    <!--【⑤配置事务属性（通知）】-->
    <tx:advice id="txAdvice" transaction-manager="txManager">
        <tx:attributes>
            <!--name属性指定当前要配置的事务方法的方法名，符合名字的配置对应规则-->
            <!--查询方法通常设置为只读，【便于数据库根据只读属性进行性能优化】-->
            <tx:method name="get*" read-only="true"/>
            <tx:method name="query*" read-only="true"/>
            <tx:method name="find*" read-only="true"/>
            <tx:method name="count*" read-only="true"/>

            <!--涉及增删改查操作的方法的配置-->
            <!--propagation属性配置事务方法的传播行为-->
            <!--默认行为：REQUIRED，表示当前方法必须运行在事务中，如果没有事务，则开启事务，在自己的事务中运行。
                    如果已经有了已开启的事务，则在当前事务中运行。有可能和其他方法共用同一个事务(有可能被一同回滚)
                建议设置：REQUIRES_NEW，表示当前方法必须运行在事务中，如果没有事务，则开启事务，在自己的事务中运行。(不会受到其他事物回滚的影响)
                    和 REQUIRED 的区别是就算现在已经有了已开启的事务，也一定要开启自己的事务，避免和其他方法共用同一个事务。
            -->

            <!--rollback-for：表示触发什么异常时，进行回滚；默认：运行时异常，建议设置为运行时异常+编译期异常-->
            <tx:method name="save*" propagation="REQUIRES_NEW" rollback-for="java.lang.Exception"/>
            <tx:method name="update*" propagation="REQUIRES_NEW" rollback-for="java.lang.Exception"/>
            <tx:method name="remove*" propagation="REQUIRES_NEW" rollback-for="java.lang.Exception"/>
            <tx:method name="batch*" propagation="REQUIRES_NEW" rollback-for="java.lang.Exception"/>
        </tx:attributes>
    </tx:advice>

    <!-- 将BCryptPasswordEncoder装配入IOC容器 -->
    <bean class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder" id="passwordEncoder"/>

</beans>
```

==注意==：在基于XML的声明式事务中，事务属性的 tx:method是必须配置的，如果某个方法没有设置对应的 			  	        tx:method，那事务对这个方法就不生效。

> 在AdminServiceImpl中测试配置事务是否成功。（testTx方法）

​	**至此持久化层的配置结束**



## 7）==表述层==

### **目标**

1. controller中装配service（service接口中定义方法，实现类具体实现，装配mapper调用数据库）

2. 页面能够访问到controller

   

### **工作机制**

按:arrow_right:顺序加载

即页面 :arrow_right: controller（@RequestMapping） :arrow_right: Service  :arrow_right:  Mapper  :arrow_right:  数据库

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220506232407290.png" alt="image-20220506232407290" style="zoom: 67%;" />

>  ==ContextLoaderListener监听器==
>
>  （1）ContextLoaderListener监听器的作用就是启动Web容器时，自动装配ApplicationContext的配置信息。因为它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。【==加载Spring 的配置文件，根据Spring 的配置文件初始化IOC 容器。==】
>
>  （2）在ContextLoaderListener中关联了ContextLoader这个类，所以整个加载配置过程由ContextLoader来完成。看看它的API说明。
>
>  具体看https://blog.csdn.net/clk_esunny/article/details/80293897

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220506232653171.png" alt="image-20220506232653171" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220507000306621.png" alt="image-20220507000306621" style="zoom: 50%;" />

> 小技巧：ctrl+shift+N快速打开文件

**<font color = red>Application==IOC容器</font>**

 

### 表述层环境搭建

**引入依赖**

使用SpringMVC 环境引入spring-webmvc 依赖即可，同时可以把spring-context 依赖去掉，     因为根据依赖的传递性，spring-webmvc 会依赖spring-context。

**配置web.xml**（web项目启动时加载）

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

   <!-- 配置ContextLoaderListener，加载Spring配置文件
    contextConfigLocation需要的内容-->
        <context-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:spring-persist-*.xml</param-value>
        </context-param>
    <!--将ContextLoaderListener加入容器-->
        <listener>
            <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
        </listener>

   <!-- 配置CharacterEncodingFilter解决POST请求的字符乱码问题
    如果web.xml中存在多个Filter，则此Filter必须作为过滤器链的第一个Filter-->
    <filter>
        <filter-name>characterEncodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <!-- 指定字符集编码 -->
        <init-param>
            <param-name>encoding</param-name>
            <param-value>UTF-8</param-value>
        </init-param>
        <!--强制请求进行编码-->
        <init-param>
            <param-name>forceRequestEncoding</param-name>
            <param-value>true</param-value>
        </init-param>
        <!--强制响应进行编码-->
        <init-param>
            <param-name>forceResponseEncoding</param-name>
            <param-value>true</param-value>
        </init-param>
    </filter>
    <!--设置过滤器的拦截的请求的路径-->
    <filter-mapping>
        <filter-name>characterEncodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>

    <!--配置DispatcherServlet（即配置SpringMVC的前端控制器）-->
    <servlet>
        <servlet-name>dispatcherServlet</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!--指定SpringMVC配置文件-->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:spring-*.xml</param-value>
        </init-param>

        <!--使DispatcherServlet在Web应用启动时就创建对象并初始化-->
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>dispatcherServlet</servlet-name>
        <!--根据请求的扩展名决定是否交给SpringMVC来处理-->
        <url-pattern>*.html</url-pattern>
        <url-pattern>*.json</url-pattern>
    </servlet-mapping>
</web-app>
```



> - 请求的扩展名和返回的数据扩展名不匹配，==406==错误(**所以要配置json扩展名**)
>
> - ==CharacterEncodingFilter==解决POST请求的字符乱码问题。需要注意的是：在 web.xml中存在多个 Filter时，让这个 Filter作为过滤器链中的**第一个** Filter。
>   **request.setCharacterEncoding(encoding)**要求必须在所有
>   **request.get**Parameter(xxx)操作前面
>   **response.set**CharacterEncoding(encoding)要求必须在所有 **response.getWriter()**操作前面
>   不满足这个顺序要求字符集设定无法生效
>
> - HiddenHttpMethodFilter
>   遵循RESTFUL风格将 POST请求转换为 PUT请求、 DELETE请求时使用。省略不配。
>
> - DispatcherServlet
>
>   以初始化参数的形式指定 SpringMVC配置文件的位置
>
> - *.html扩展名
>   举例
>   http://localhost:8080/atcrowdfunding02-admin-webui/save/emp.html
>
>   作用：伪静态
>   表面上看起来是一个访问静态资源的请求，但是实际上是由SpringMVC交给 handler来处理的动态资源。
>
>   - 好处 1：有利于 SEO优化
>
>     让搜索引擎更容易找到我们的网站，有利于网站的推广
>
>   - 好处 2：隐藏后端技术实现细节,给黑客入侵系统增加难度
>
>   - 好处 3：自动解决静态资源访问问题
>
>     访问a.png本身不符合 *.html这个 url-pattern，和 SpringMVC完全没有关系，当前请求由 Tomcat处理。如果url pattern映射了“/”，那么 SpringMVC中还需要配置DefaultServletHandler。
>
>   - 缺陷：不符合 RESTFUL风格
>
> - *.json扩展名
>
>   - 描述问题
>     请求扩展名 http://localhost:8080/extra01-ajax/get/emp/by/ajax.html
>     服务器端打算返回的数据：JSON格式
>     二者不匹配！！！
>     分析问题
>     请求扩展名和响应体的数据格式不匹配！！！
>     解决问题
>     让请求扩展名和预计的响应体数据格式一致。
>     http://localhost:8080/extra01-ajax/get/emp/by/ajax.json
>     同时让SpringMVC在映射 *.html扩展名之外再 映射 ***.json**扩展名 ，不然会返回 **404**
>
>   ```xml
>   Map all requests to the DispatcherServlet for handling ---->
>   <servlet mapping>
>   <servlet name>springDispatcherServlet</servlet name>
>   <url pattern>*.html</url pattern>
>   <url pattern>*.json</url pattern>
>   </servlet mapping>
>   ```
>
>   **处理ajax请求过程**
>
>   <img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220507135354296.png" alt="image-20220507135354296" style="zoom: 50%;" />

**包结构**

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220507140630299.png" alt="image-20220507140630299" style="zoom:67%;" />



### ==SpringMVC重要知识点==

##### SpringMVC 环境下的Ajax 请求

前端发送过来，后端要处理的请求有两种：

- 普通请求：后端处理完成后**返回页面**，浏览器使用使用页面替换整个窗口中的内容
- Ajax 请求：后端处理完成后通常**返回JSON 数据**，jQuery 代码使用JSON 数据对页面局部更新



##### @RequestBody与@ResponseBody

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220507144221695.png" alt="image-20220507144221695" style="zoom:67%;" />

###### <font color = red>@**RequestBody**</font>

**作用**：==将请求体的数据交给java代码处理（加载参数上，一个实体对应一个参数，参数不在请求的URL中）==

**注意**：

- 前端

  -  首先准备好要发送的JSON 数据
     JSON 对象

     JSON 数组

  - **将JSON 对象或JSON 数组转换为JSON 字符串**

    ==var arrayStr = JSON.stringify(array);==

  - **将JSON 字符串直接赋值给data 属性**

    "data":arrayStr

  - ==必须要设置**contentType**==

    "contentType":"application/json;charset=UTF-8"**（告诉服务器端当前请求的请求体是JSON 格式）**

- 后端

  - 加入jackson 依赖

  - 开启注解驱动

  - 使用注解

    @RequestBody Integer[] empIdArray

**总结：**==@RequestBody 使用的场景==：传统发送请求参数方式不方便发送的数据，使用JSON 请求体的方式发送。特别是要发送复杂对象的时候。



###### **@ResponseBody**

**作用**: ==让controller（handler） 方法的返回值本身就是当前请求的响应数据。不再参考视图处理器中配置的前后缀信息。==

**注意**：

- 开启SpringMVC 的注解驱动<mvc:annotation-driven>
- 必须有jackson 依赖
  jackson-core
  jackson-databind
-  扩展名需要和实际返回的数据格式一致
  响应体返回JSON
  请求扩展名*.json
  web.xml 中DispatcherServlet 必须映射*.json 扩展名



<font color = red>**测试**</font>:

引入jsp与servlet的依赖

部署的war包中的依赖要导全（利用maven install）

web.xml文件要配置正确

```java
@Autowired
private AdminService adminService;

@RequestMapping("/test/ssm.html")
public String testSsm(ModelMap modelMap){
    List<Admin> adminList = adminService.getAll();
    modelMap.addAttribute("adminList",adminList);
    return "target";
}
```

index.jsp:

```jsp
</head>
<body>
    <a href="${pageContext.request.contextPath}/test/ssm.html">测试SSM整合环境</a>
</body>
</html>
```

target.jsp:

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>success</title>
</head>
<body>
    成功进入页面！<br/>
    ${requestScope.adminList}
</body>
</html>
```

==service实现类中的方法记得写上。==



<font color = green>关于如何使用@RequestBody注解处理ajax方式发送的**Json**请求体，前端用jquery写，看**p48**</font>

> ```java
> <scope>provided</scope>表示不参与部署（到war包）
> ```
>
> base 标签必须写在 head 标签内部
> base 标签必须在所有“带具体路径”的标签的前面
> serverName 部分 EL 表达式和 serverPort 部分 EL 表达式之间必须写“:”
> serverPort 部分 EL 表达式和 contextPath 部分 EL 表达式之间绝对不能写“/”
> 原因：contextPath 部分 EL 表达式本身就是“/”开头
> 如果多写一个“/”会干扰 Cookie 的工作机制
> serverPort 部分 EL 表达式后面必须写“/”
>
> 
>
> Code400：请求参数错误
>
> ==maven 的clean 需要将相关联（前置模块）清干净才能install成功==
>
> 如下图，模块之间的互相依赖也要导入，还是尽量借助maven工具以免出错
>
> <img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220507222847348.png" alt="image-20220507222847348" style="zoom:50%;" />



###### Ajax发送数组 

**方案一（不推荐）：**

controller

```java
package com.x.crowd.mvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.List;

@Controller
public class TestAjaxController {

    @ResponseBody
    @RequestMapping("send/array/one.html")
    public String testReceiveArrayOne(@RequestParam("array") List<Integer> array) {
        for (Integer num : array) {
            System.out.println("num = " + num);
        }
        return "target";
    }
}
```

jsp：

```javascript
        $(function () {
            //btn1
            /**
            *//此方式可以在浏览器看到发送的请求体是Form Data(表单数据)，
            */新版在payload（请求负载）中看
            */
            $("#btn1").click(function () {
                $.ajax({
                    url: "send/array/one.html",                   //请求目标资源地址
                    type: "post",                                 //请求方式
                     data: {"array":[5,8,2]},                      //发送的请求参数
                    dataType: "text",                             //表示如何对待服务器返回的数据
                    // contentType: "application/json;charset=UTF-8",//告诉服务器端当前请求的请求体是JSON格式
                    success: function (response) {
                        alert(response);
                    },
                    error: function (response) {
                        alert(response);
                    }
                });
            });
        });

```

没有出现jquery在数据中添加 [] 的问题，但是有**%5B%5D**问题

[解决]: https://blog.csdn.net/weixin_44721355/article/details/120668240?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-120668240-blog-119506642.pc_relevant_antiscanv2&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-120668240-blog-119506642.pc_relevant_antiscanv2&amp;utm_relevant_index=1

**方案二（不成立）**

```javascript
$(function () {
    //btn2
    //此方式可以在浏览器看到发送的请求体是Form Data(表单数据)，新版在payload（请求负载）中看
    $("#btn2").click(function () {
        $.ajax({
            url: "send/array/two.html",                   //请求目标资源地址
            type: "post",                                 //请求方式
            data: {
                "array":5,
                "array":2,
                "array":8,  //这个操作相当于赋值，那么只会保留最后一个
                            //array[]:5也不行，只能用一个类的对象（是array）来传参
            },                      //发送的请求参数
            dataType: "text", ...});                        
```

###### **方案三（推荐）**

**jsp：**

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>测试</title>
    <%--
        base 标签必须写在 head 标签内部
        base 标签必须在所有“带具体路径”的标签的前面
        serverName 部分 EL 表达式和 serverPort 部分 EL 表达式之间必须写“:”
        serverPort 部分 EL 表达式和 contextPath 部分 EL 表达式之间绝对不能写“/”
        原因：contextPath 部分 EL 表达式本身就是“/”开头
        如果多写一个“/”会干扰 Cookie 的工作机制
        serverPort 部分 EL 表达式后面必须写“/”
    --%>
    <base href="http://${pageContext.request.serverName}:${pageContext.request.serverPort}${pageContext.request.contextPath}/">
    <script src="jquery/jquery-1.7.1.min.js" type="text/javascript"></script>
    <script src="layer/layer.js" type="text/javascript"></script>
    <script type="text/javascript">
        jQuery.ajaxSettings.traditional = true;//禁用jQuery对数组参数做的序列化操作

        $(function (){
            $("#btn3").click(function () {
            //准备好要发送到服务器端的数组
            var array = [1,2,3];
            console.log(array.length);

            //将JSON数组转换为JSON字符串
            var  requestBody = JSON.stringify(array);
            //"['1','2','3']"
            console.log(requestBody.length);

            $.ajax({
                url: "send/array/three.html",         //请求目标资源地址
                type: "post",                       //请求方式
                data: requestBody,                     //请求体
                dataType: "text",                   //表示如何对待服务器返回的数据
                contentType: "application/json;charset=UTF-8",  //告诉服务器端当前请求的请求体是JSON格式
                success: function (response) {
                    alert(response);
                },
                error: function (response) {
                    alert(response);
                }
            });
        });
        });
 
    </script>
</head>
<body>
<%--无base标签：
   <a href="${pageContext.request.contextPath}/test/ssm.html">测试页面</a>
--%>
<%--有base标签  --%>
<a href="test/ssm.html">测试SSM整合环境</a>
<br/><br/>
<button id="btn1">Test Ajax one</button>
<br/><br/>
<button id="btn2">Test Ajax two</button>
<br/><br/>
<button id="btn3">Test Ajax three</button>
</body>
</html>
```

**controller**

```java
package com.x.crowd.mvc.controller;

import com.mysql.cj.log.Log;
import com.mysql.cj.log.LogFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.List;

@Controller
public class TestAjaxController {

    @ResponseBody//将方法返回值做为响应体返回
    @RequestMapping("send/array/three.html")
    public String testReceiveArrayThree(@RequestBody List<Integer> array) {
        Logger logger = LoggerFactory.getLogger(TestAjaxController.class);

        for (Integer num : array) {
            logger.info("num:"+num);
        }
        return "target";
    }

}
```

**对比：**

![image-20220508003920904](https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220508003920904.png)



###### ==统一Ajax请求规范(返回的数据格式)==

==**ResultEntity:**==

****

```java
package com.x.crowd.util;

/**
 * 用于统一项目中所有 Ajax请求的返回值类型
 * @author Lenovo
 *
 * @param <T>
 */
public class ResultEntity<T> {
    public static final String SUCCESS = "SUCCESS";
    public static final String FAILED = "FAILED";
    public static final String NO_MESSAGE = "NO_MESSAGE";
    public static final String NO_DATA = "NO_DATA";
    /**
     * 返回操作结果为成功，不带数据
     * @return
     */
    public static <E> ResultEntity<E> successWithoutData() {
        return new ResultEntity<E>(SUCCESS, NO_MESSAGE, null);
    }
    /**
     * 返回操作结果为成功，携带数据
     * @param data
     * @return
     */
    public static <E> ResultEntity<E> successWithData(E data) {
        return new ResultEntity<E>(SUCCESS, NO_MESSAGE, data);
    }
    /**
     * 返回操作结果为失败，不带数据
     * @param message
     * @return
     */
    public static <E> ResultEntity<E> failed(String message) {
        return new ResultEntity<E>(FAILED, message, null);
    }
    private String operationResult;
    private String operationMessage;
    private T queryData;
    public ResultEntity() {
    }
    public ResultEntity(String operationResult, String operationMessage, T queryData) {
        super();
        this.operationResult = operationResult;
        this.operationMessage = operationMessage;
        this.queryData = queryData;
    }
    @Override
    public String toString() {
        return "AjaxResultEntity [operationResult=" + operationResult + ", operationMessage=" + operationMessage
                + ", queryData=" + queryData + "]";
    }
    public String getOperationResult() {
        return operationResult;
    }
    public void setOperationResult(String operationResult) {
        this.operationResult = operationResult;
    }
    public String getOperationMessage() {
        return operationMessage;
    }
    public void setOperationMessage(String operationMessage) {
        this.operationMessage = operationMessage;
    }
    public T getQueryData() {
        return queryData;
    }
    public void setQueryData(T queryData) {
        this.queryData = queryData;
    }
}

```



### ==<font color = red>ResultEntity详解</font>==

创建这个实体类用于统一ajax请求返回的数据格式，实体类中封装了需要的==可定制==的属性：如处理结果、返回信息、返回数据等，通过构造器生成响应的要返回的方法，get、set方法调用属性。

**Controller层方法统一类型（返回值）为这个==ResultEntity<数据类型>==**，在**js函数**中将处理结果封装到相应的属性中以json格式返回。如此便统一了返回的数据。



### ==异常映射==

**作用 **：==统一管理项目中的异常==

- 抛出异常
- 显示异常信息
- 普通请求：在页面上显示异常信息
- Ajax请求：返回 JSON数据

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220513105021299.png" alt="image-20220513105021299" style="zoom:67%;" />=

==**注意：**==xml和注解配置方式的映射方式不同

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220513105154467.png" alt="image-20220513105154467" style="zoom:67%;" />



#### 判断依据

**<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220513144818661.png" alt="image-20220513144818661" style="zoom:67%;" />**

==**依此创建工具类**==

**CrowdUtil:**

```java
package com.x.crowd.util;

import javax.servlet.http.HttpServletRequest;

public class CrowdUtil {
    /**
     * 判断当前请求是否为Ajax请求
     * @param request
     * @return
     */
    public static boolean judgeRequestType(HttpServletRequest request) {
// 1.获取请求消息头信息
        String acceptInformation = request.getHeader("Accept");
        String xRequestInformation = request.getHeader("X-Requested-With");
        // 2.检查并返回(因为返回值就是boolean类型的所以不用if判断了)
        return (acceptInformation != null && acceptInformation.length() > 0 && acceptInformation.contains("application/json"))
                ||
                (xRequestInformation != null && xRequestInformation.length() > 0 && xRequestInformation.equals("XMLHttpRequest"));
    }
}
```



#### 实现方式

##### 基于xml方式

```xml
  <!--基于XML的异常映射-->
    <bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver" id="simpleMappingExceptionResolver">
        <property name="exceptionMappings">
            <props>
                <!--key属性指定异常全类名-->
                <!--值要拼前后缀得到具体路径-->
                 <prop key="java.lang.Exception">system-error</prop>
            </props>
        </property>
    </bean>
```

##### ==基于注解方式==

这里通过使用前面编写的工具类的判断方法，实现对不同请求类型进行不同处理。

```java
//注解：标明该类是基于注解的异常处理器类（实测，注解版异常处理比xml版本优先生效）
@ControllerAdvice
public class CrowdExceptionResolver {

    // 处理其他异常
    @ExceptionHandler(value = {Exception.class})
    public ModelAndView resolveException(Exception exception,
            HttpServletRequest request, HttpServletResponse response
    ) throws IOException {
        return commonCode(exception,request,response,"system-error");
    }

    // 处理数学异常,这里如果内部操作相同，跳转页面也相同，其实可以放在上面一个方法中，此处只是为了演示
    @ExceptionHandler(value = {ArithmeticException.class})
    public ModelAndView resolveArithmeticException(ArithmeticException exception,
            HttpServletRequest request,HttpServletResponse response) throws IOException {
        return commonCode(exception,request,response,"system-error");

    }
    
    // 触发登录失败异常，则继续返回登陆页面
    @ExceptionHandler(value = LoginFailedException.class)
    public ModelAndView resolverLoginFailedException(
            LoginFailedException exception, HttpServletRequest request,
            HttpServletResponse response) throws IOException {
        String viewName = "admin-login";
        return commonCode(exception,request,response,viewName);
    }

    // 整理出的不同异常的可重用代码
    private ModelAndView commonCode(
            //触发的异常，此处借助多态
            Exception exception,
            //客户器端的请求
            HttpServletRequest request,
            //服务端的响应
            HttpServletResponse response,
            //指定普通页面请求时，去的错误页面
            String viewName
    ) throws IOException {
        boolean judgeRequestType = CrowdUtil.judgeRequestType(request);
        if (judgeRequestType){
            //if判断-是json请求
            ResultEntity<Object> failed = ResultEntity.failed(exception.getMessage());
            //创建Gson对象
            Gson gson = new Gson();
            //将ResultEntity对象转换成json格式
            String json = gson.toJson(failed);
            //通过原生servlet的response传回异常内容
            response.getWriter().write(json);
            //此时只需要返回null（因为是通过json格式返回数据）
            return null;
        } else {
            //if判断-是普通页面请求
            //创建ModelAndView对象
            ModelAndView modelAndView = new ModelAndView();
            //设置触发异常跳转的页面（会自动被视图解析器加上前后缀）
            modelAndView.setViewName(viewName);
            //将异常信息加入
            modelAndView.addObject(CrowdConstant.ATTR_NAME_EXCEPTION, exception);
            //返回设置完成的ModelAndView
            return modelAndView;
        }
    }


}
```

### **以常量管理常用的属性**

> 异常处理器的优化：
>
> **CrowdExceptionResolver**：封装异常处理的代码，抽取公用代码，**Constant**将提示消息提取成常量统一管理**（常量中最好不要使用魔法值{无法见名知意的值}）**
>
> （防止敲错，最好复制粘贴，或者定义常量类）



### 引入前端界面

> 开发中有**服务器端渲染**（用渲染模板） 和 **前后端分离**

**引入前端静态资源**

<img src="https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220514144123965.png" alt="image-20220514144123965" style="zoom:67%;" />

```xml
<!--配置view-controller，直接将请求地址和视图名称关联起来，不必写handler方法了-->
<!--通过view-controller 来设置一些直接的页面跳转-->
<!--去登录页面-->
<mvc:view-controller path="/admin/login/page.html" view-name="admin-login"/>
```

**引入layui（js文件是layui.all.js）**

![image-20220514151545002](https://raw.githubusercontent.com/xj-070/MarkDown/project/myproject/crowdfunding/image-20220514151545002.png)

> ​	==注意==：layer组件依赖于jquery，因此layer的引入必须在jquery之后，否则会出错。

> **关于requestScope**：
>
> ```jsp
> <%--requestScope对应的是存放request域数据的Map
>     requestScope.exception相当于request.getAttribute("exception")
>     requestScope.excption.message相当于exception.getMessage()
> --%>
> <h2 style="text-align: center;">错误消息：${requestScope.exception.message}</h2>
> ```



